{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Example Express app deployed on k8s # Welcome # First off, hello and welcome to the landing page of my app\u2019s documentation. My name is Calvin and I work in the sales organization at Juniper Networks; I hope that you will find this project helpful. This project will stand up an example Express application with a working REST API with a handful of functions. A mongodb database will provide the necessary feature of storing and retrieving data for our little app. Containers # nodejs # A Dockerfile has been provided at files/nodejs ; it is based on node:alpine and simply executes our code after copying it into the /usr/src/app directory. mongodb # Our database platform will be based upon the official mongo:latest image and requires no modification, so the only trace of it will be found in the files/docker-compose.yaml file. Docker Compose # A docker-compose.yaml file has been provided for local testing only. Remember our goal is to deploy this to a k8s cluster. Data Model # For our requests, we\u2019ll need to align ourselves with the data model defined in files/nodejs/models/model.js // files/nodejs/models/model.js const taskSchema = new mongoose . Schema ({ name : { type : String , required : 'Enter the name of the task' }, date_created : { type : Date , default : Date . now }, status : { type : [{ type : String , enum : [ 'pending' , 'ongoing' , 'completed' ] }], default : [ 'pending' ] } }); API methods # The URI for our API methods will end with /tasks or /tasks/:taskId Create a new task # HTTP Method API URI Body ID POST /tasks True body { \"status\" : [ \"pending\" ], \"name\" : \"test out api methods\" } Get list of tasks # HTTP Method API URI Body ID GET /tasks False Delete task # HTTP Method API URI Body ID DELETE /tasks/:taskId False This page is automatically generated using a Python script within the .github directory Deploy to Kubernetes # This example had been pulled directly from the official documentation , so feel confident that this will work. My intent is to adjust this example later to my example. The first thing to do is create the MongoDB Service. This service is used by the other Pods in the cluster to find and connect to the MongoDB instance. apiVersion : v1 kind : Service metadata : labels : name : mongo name : mongo spec : ports : - port : 27017 targetPort : 27017 selector : name : mongo Download file This service looks for all pods with the \u201cmongo\u201d tag, and creates a Service on port 27017 that targets port 27017 on the MongoDB pods. Port 27017 is the standard MongoDB port. To start the service, run: kubectl create -f files/k8s/mongodb-service.yaml Creating the MongoDB Controller # Next, create the MongoDB instance that runs the Database. Databases also need persistent storage, which will be different for each platform. apiVersion : v1 kind : ReplicationController metadata : labels : name : mongo name : mongo-controller spec : replicas : 1 template : metadata : labels : name : mongo spec : containers : - image : mongo name : mongo ports : - name : mongo containerPort : 27017 hostPort : 27017 volumeMounts : - name : mongo-persistent-storage mountPath : /data/db volumes : - name : mongo-persistent-storage gcePersistentDisk : pdName : mongo-disk fsType : ext4 Download file Looking at this file from the bottom up: First, it creates a volume called \u201cmongo-persistent-storage.\u201d In the above example, it is using a \u201cgcePersistentDisk\u201d to back the storage. This is only applicable if you are running your Kubernetes cluster in Google Cloud Platform. Create this controller with this command: kubectl create -f files/k8s/mongodb-controller.yaml At this point, MongoDB is up and running. Note: There is no password protection or auth running on the database by default. Please keep this in mind! Creating the Node.js Service # The next step is to create the Node.js service. This service is what will be the endpoint for the web site, and will load balance requests to the Node.js instances. apiVersion : v1 kind : Service metadata : name : web labels : name : web spec : type : LoadBalancer ports : - port : 80 targetPort : 3000 protocol : TCP selector : name : web Download file This service is called \u201cweb,\u201d and it uses a LoadBalancer to distribute traffic on port 80 to port 3000 running on Pods with the \u201cweb\u201d tag. Port 80 is the standard HTTP port, and port 3000 is the standard Node.js port. On Google Container Engine, a network load balancer and firewall rule to allow traffic are automatically created. To start the service, run: kubectl create -f files/k8s/web-service.yaml If you are running on a platform that does not support LoadBalancer (i.e Bare Metal), you need to use a NodePort with your own load balancer. You may also need to open appropriate Firewall ports to allow traffic. Creating the Node.js Controller # The final step is deploying the Node.js container that will run the application code. This container can easily by replaced by any other web serving frontend, such as Rails, LAMP, Java, Go, etc. The most important thing to keep in mind is how to access the MongoDB service. If you were running MongoDB and Node.js on the same server, you would access MongoDB like so: MongoClient . connect ( 'mongodb://localhost:27017/database-name' , function ( err , db ) { console . log ( db ); }); With this Kubernetes setup, that line of code would become: MongoClient . connect ( 'mongodb://mongo:27017/database-name' , function ( err , db ) { console . log ( db ); }); The MongoDB Service previously created tells Kubernetes to configure the cluster so \u2018mongo\u2019 points to the MongoDB instance created earlier. Custom Container # You should have your own container that runs your Node.js code hosted in a container registry. See this example to see how to make your own Node.js container. Once you have created your container, create the web controller. apiVersion : v1 kind : ReplicationController metadata : labels : name : web name : web-controller spec : replicas : 2 selector : name : web template : metadata : labels : name : web spec : containers : - image : <YOUR-CONTAINER> name : web ports : - containerPort : 3000 name : http-server Download file Replace with the url of your container. This Controller will create two replicas of the Node.js container, and each Node.js container will have the tag \u201cweb\u201d and expose port 3000. The Service LoadBalancer will forward port 80 traffic to port 3000 automatically, along with load balancing traffic between the two instances. To start the Controller, run: kubectl create -f files/k8s/web-controller.yaml Demo Container # If you DON\u2019T want to create a custom container, you can use the following YAML file: Note: You cannot run both Controllers at the same time, as they both try to control the same Pods. apiVersion : v1 kind : ReplicationController metadata : labels : name : web name : web-controller spec : replicas : 2 selector : name : web template : metadata : labels : name : web spec : containers : - image : node:0.10.40 command : [ '/bin/sh' , '-c' ] args : [ 'cd /home && git clone https://github.com/ijason/NodeJS-Sample-App.git demo && cd demo/EmployeeDB/ && npm install && sed -i -- '' s/localhost/mongo/g '' app.js && node app.js' ] name : web ports : - containerPort : 3000 name : http-server Download file This will use the default Node.js container, and will pull and execute code at run time. This is not recommended; typically, your code should be part of the container. To start the Controller, run: kubectl create -f files/k8s/web-controller-demo.yaml","title":"Homepage"},{"location":"#example-express-app-deployed-on-k8s","text":"","title":"Example Express app deployed on k8s"},{"location":"#welcome","text":"First off, hello and welcome to the landing page of my app\u2019s documentation. My name is Calvin and I work in the sales organization at Juniper Networks; I hope that you will find this project helpful. This project will stand up an example Express application with a working REST API with a handful of functions. A mongodb database will provide the necessary feature of storing and retrieving data for our little app.","title":"Welcome"},{"location":"#containers","text":"","title":"Containers"},{"location":"#nodejs","text":"A Dockerfile has been provided at files/nodejs ; it is based on node:alpine and simply executes our code after copying it into the /usr/src/app directory.","title":"nodejs"},{"location":"#mongodb","text":"Our database platform will be based upon the official mongo:latest image and requires no modification, so the only trace of it will be found in the files/docker-compose.yaml file.","title":"mongodb"},{"location":"#docker-compose","text":"A docker-compose.yaml file has been provided for local testing only. Remember our goal is to deploy this to a k8s cluster.","title":"Docker Compose"},{"location":"#data-model","text":"For our requests, we\u2019ll need to align ourselves with the data model defined in files/nodejs/models/model.js // files/nodejs/models/model.js const taskSchema = new mongoose . Schema ({ name : { type : String , required : 'Enter the name of the task' }, date_created : { type : Date , default : Date . now }, status : { type : [{ type : String , enum : [ 'pending' , 'ongoing' , 'completed' ] }], default : [ 'pending' ] } });","title":"Data Model"},{"location":"#api-methods","text":"The URI for our API methods will end with /tasks or /tasks/:taskId","title":"API methods"},{"location":"#create-a-new-task","text":"HTTP Method API URI Body ID POST /tasks True body { \"status\" : [ \"pending\" ], \"name\" : \"test out api methods\" }","title":"Create a new task"},{"location":"#get-list-of-tasks","text":"HTTP Method API URI Body ID GET /tasks False","title":"Get list of tasks"},{"location":"#delete-task","text":"HTTP Method API URI Body ID DELETE /tasks/:taskId False This page is automatically generated using a Python script within the .github directory","title":"Delete task"},{"location":"#deploy-to-kubernetes","text":"This example had been pulled directly from the official documentation , so feel confident that this will work. My intent is to adjust this example later to my example. The first thing to do is create the MongoDB Service. This service is used by the other Pods in the cluster to find and connect to the MongoDB instance. apiVersion : v1 kind : Service metadata : labels : name : mongo name : mongo spec : ports : - port : 27017 targetPort : 27017 selector : name : mongo Download file This service looks for all pods with the \u201cmongo\u201d tag, and creates a Service on port 27017 that targets port 27017 on the MongoDB pods. Port 27017 is the standard MongoDB port. To start the service, run: kubectl create -f files/k8s/mongodb-service.yaml","title":"Deploy to Kubernetes"},{"location":"#creating-the-mongodb-controller","text":"Next, create the MongoDB instance that runs the Database. Databases also need persistent storage, which will be different for each platform. apiVersion : v1 kind : ReplicationController metadata : labels : name : mongo name : mongo-controller spec : replicas : 1 template : metadata : labels : name : mongo spec : containers : - image : mongo name : mongo ports : - name : mongo containerPort : 27017 hostPort : 27017 volumeMounts : - name : mongo-persistent-storage mountPath : /data/db volumes : - name : mongo-persistent-storage gcePersistentDisk : pdName : mongo-disk fsType : ext4 Download file Looking at this file from the bottom up: First, it creates a volume called \u201cmongo-persistent-storage.\u201d In the above example, it is using a \u201cgcePersistentDisk\u201d to back the storage. This is only applicable if you are running your Kubernetes cluster in Google Cloud Platform. Create this controller with this command: kubectl create -f files/k8s/mongodb-controller.yaml At this point, MongoDB is up and running. Note: There is no password protection or auth running on the database by default. Please keep this in mind!","title":"Creating the MongoDB Controller"},{"location":"#creating-the-nodejs-service","text":"The next step is to create the Node.js service. This service is what will be the endpoint for the web site, and will load balance requests to the Node.js instances. apiVersion : v1 kind : Service metadata : name : web labels : name : web spec : type : LoadBalancer ports : - port : 80 targetPort : 3000 protocol : TCP selector : name : web Download file This service is called \u201cweb,\u201d and it uses a LoadBalancer to distribute traffic on port 80 to port 3000 running on Pods with the \u201cweb\u201d tag. Port 80 is the standard HTTP port, and port 3000 is the standard Node.js port. On Google Container Engine, a network load balancer and firewall rule to allow traffic are automatically created. To start the service, run: kubectl create -f files/k8s/web-service.yaml If you are running on a platform that does not support LoadBalancer (i.e Bare Metal), you need to use a NodePort with your own load balancer. You may also need to open appropriate Firewall ports to allow traffic.","title":"Creating the Node.js Service"},{"location":"#creating-the-nodejs-controller","text":"The final step is deploying the Node.js container that will run the application code. This container can easily by replaced by any other web serving frontend, such as Rails, LAMP, Java, Go, etc. The most important thing to keep in mind is how to access the MongoDB service. If you were running MongoDB and Node.js on the same server, you would access MongoDB like so: MongoClient . connect ( 'mongodb://localhost:27017/database-name' , function ( err , db ) { console . log ( db ); }); With this Kubernetes setup, that line of code would become: MongoClient . connect ( 'mongodb://mongo:27017/database-name' , function ( err , db ) { console . log ( db ); }); The MongoDB Service previously created tells Kubernetes to configure the cluster so \u2018mongo\u2019 points to the MongoDB instance created earlier.","title":"Creating the Node.js Controller"},{"location":"#custom-container","text":"You should have your own container that runs your Node.js code hosted in a container registry. See this example to see how to make your own Node.js container. Once you have created your container, create the web controller. apiVersion : v1 kind : ReplicationController metadata : labels : name : web name : web-controller spec : replicas : 2 selector : name : web template : metadata : labels : name : web spec : containers : - image : <YOUR-CONTAINER> name : web ports : - containerPort : 3000 name : http-server Download file Replace with the url of your container. This Controller will create two replicas of the Node.js container, and each Node.js container will have the tag \u201cweb\u201d and expose port 3000. The Service LoadBalancer will forward port 80 traffic to port 3000 automatically, along with load balancing traffic between the two instances. To start the Controller, run: kubectl create -f files/k8s/web-controller.yaml","title":"Custom Container"},{"location":"#demo-container","text":"If you DON\u2019T want to create a custom container, you can use the following YAML file: Note: You cannot run both Controllers at the same time, as they both try to control the same Pods. apiVersion : v1 kind : ReplicationController metadata : labels : name : web name : web-controller spec : replicas : 2 selector : name : web template : metadata : labels : name : web spec : containers : - image : node:0.10.40 command : [ '/bin/sh' , '-c' ] args : [ 'cd /home && git clone https://github.com/ijason/NodeJS-Sample-App.git demo && cd demo/EmployeeDB/ && npm install && sed -i -- '' s/localhost/mongo/g '' app.js && node app.js' ] name : web ports : - containerPort : 3000 name : http-server Download file This will use the default Node.js container, and will pull and execute code at run time. This is not recommended; typically, your code should be part of the container. To start the Controller, run: kubectl create -f files/k8s/web-controller-demo.yaml","title":"Demo Container"}]}